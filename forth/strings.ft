\ String, symbol and keyword handlers.
\ Strings are stored as two cells and a buffer:
\ [ %string | length | chars...]
\ The buffer may be padded to a round length, but that's the GC's business.

: s>len  ( string -- 'length ) cell+ ;
: s>data ( string -- c-addr  ) 2 cells + ;
: length ( string -- length ) s>len @ ;
: s>str  ( string -- c-addr u ) dup s>data swap length ;

\ Printer
: ?escaped ( ch -- ch' ? )
  dup 10 =       IF drop 'n' true EXIT THEN
  dup [char] " =   over [char] \ = or ;

: str-pr-readably ( c-addr u -- )
  [CHAR] " pinch
  0 ?DO ( c-addr )
    dup i + c@
    ?escaped IF [char] \ pinch THEN
    pinch
  LOOP drop
  [CHAR] " pinch ;

:noname ( string -- )
  s>str   print-readably? @ IF str-pr-readably ELSE prn-type THEN ;
%string method-of (pr-str)

\ Symbols are stored like strings but with a different type.
:noname ( symbol -- ) s>str prn-type ; %symbol method-of (pr-str)

\ Likewise keywords are stored as strings (without their colon)
\ TODO: Intern keywords as intended!
:noname ( keyword -- ) [char] : pinch   s>str prn-type ; %keyword method-of (pr-str)

\ Constructors ===============================================================
\ Like MOVE, but handles escaping on the way through.
VARIABLE (unescape?)
VARIABLE (unescape-next?)
: (unescape-ch) ( ch -- ch' ) dup 'n' = IF drop 10 THEN ;
: (unescape) ( src dst u -- len )
  (unescape?) @ 0= IF dup >R move R> EXIT THEN
  swap >R     ( src u     R: dst )
  over + swap ( end src   R: dst )
  R@ -rot ?DO ( dst )
    i c@   dup [char] \ =   (unescape-next?) @ 0= and IF
      drop (unescape-next?) on
    ELSE
      (unescape-next?) @ IF (unescape-ch) THEN
      (unescape-next?) off
      over c! char+
    THEN
  LOOP
  R> - (unescape?) off ;

: (>stringy) ( c-addr u %type -- value )
  over 2 cells + aligned allocate throw >R
  R@ !                      \ Write the type      ( c-addr u   R: value )
  R@ s>data swap (unescape) \ Copy the contents          ( len R: value )
  R@ s>len !                \ Write the unescaped length     ( R: value )
  R> ;

: >symbol  ( c-addr u -- symbol ) %symbol  (>stringy) ;
: >string  ( c-addr u -- string ) %string  (>stringy) ;
: >keyword ( c-addr u -- keyword) %keyword (>stringy) ;

\ Comparison =================================================================
:noname ( x y -- -1|0|1 )
  %?cmp
  2dup >R s>str R> s>str ( x y x-addr xu y-addr yu )
  rot min 0 ?DO ( x y x-addr y-addr )
    over i + c@   over i + c@   cmp ?dup IF ( x y x-addr y-addr -1|1 )
      >R 2drop 2drop R> UNLOOP EXIT THEN
  LOOP ( x y x-addr y-addr )
  2drop \ The longer string is the winner.
  length >R length R> cmp ;
  dup %string  method-of compare
  dup %symbol  method-of compare
      %keyword method-of compare

\ Eval =======================================================================
\ Strings and keywords are already eval'd.
\ Symbols, however, eval by being looked up in the environment.
CREATE fail-get-sentinel

6 CONSTANT err-unknown-symbol

:noname ( env symbol -- value ) swap env-get ; %symbol method-of eval-ast


\ Static symbols =============================================================
\ Defines a Mal symbol as a Forth CREATEd word, named 'word
\ These are static so as to be outside of GC.
: static-sym ( "word" --     X: -- symbol )
  S" CREATE '" pad     swap move
  parse-name
  2dup         pad 8 + swap move ( c-addr u    Pad now reads: CREATE 'word )
  dup 8 +   pad swap EVALUATE    ( c-addr u )
  %symbol ,   dup ,              \ Write %symbol and length
  here over allot align          ( src u dst )
  swap move ( ) ;

\ Used by the reader.
static-sym deref
static-sym concat
static-sym cons
static-sym quote
static-sym quasiquote
static-sym unquote
static-sym splice-unquote

static-sym list-seq
static-sym &
static-sym vec
