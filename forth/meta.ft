\ Some Forth meta magic - like the "multimethods" style overloading.

\ Use these sort of like a Clojure multimethod:
\ Define the multi in one place like
\   multi pr-str    ok
\ which defines slots for #types implementations, each holding an xt.
\ Then you can set the implementation for a particular type like this:
\   :noname ... ; %string method-of pr-str    ok

1 CONSTANT err-no-impl

\ This is the default implementation - it prints an error using the name token.
: (no-impl) ( mal-value body -- )
  ." *** No implementation for " #types cells + @ id. ." for type " % . cr
  err-no-impl throw ;

\ Multis have #types 1+ cells of space: the #types xts, plus its own nt for errors.
: multi ( "name" --    X: mal-value -- mal-value )
    CREATE   #types 0 DO 0 , LOOP   latest ,
  DOES> ( mal-value 'xts ) over % cells over + @ ( mal-value 'xts xt )
    \ over #types cells + @ id. 2 pick % . cr
    dup IF nip execute ELSE drop (no-impl) THEN ;

: method-of ( xt %type "name" -- ) cells ' >body + ! ;


\ Declaring some multi-methods early so each type can implement them.
multi compare ( x y -- -1 | 0 | 1 ) \ -1 -> x < y; 1 -> x > y


multi eval-ast ( env form -- form )
\ Many types just eval to themselves: numbers, strings, keywords, nil, booleans.
:noname nip ;
  dup %nil      method-of eval-ast
  dup %number   method-of eval-ast
  dup %bool     method-of eval-ast
  dup %string   method-of eval-ast
  dup %keyword  method-of eval-ast
  dup %builtin  method-of eval-ast
      %function method-of eval-ast

DEFER EVAL

multi seq
multi first
multi rest

:noname ;
  dup %list-seq   method-of seq
  dup %vector-seq method-of seq
  dup %map-seq    method-of seq

  \ Nil acts like a seq that returns nil for everything.
  dup %nil        method-of seq
  dup %nil        method-of first
      %nil        method-of rest

multi mal-count

