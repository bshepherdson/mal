\ Reader functions

\ Reader bookkeeping =========================================================
\ The current reader's state. This points to three cells:
\ [ token-len | c-addr | remaining-length ]
\ The first two form a Forth string for the current token, in 2@ order.
\ The third cell gives the remaining length of the string in total.
VARIABLE reader

: reader>c-addr cell+ ;
: reader>len    ;
: reader>tail  2 cells + ;

: >reader ( c-addr ) reader @ reader>c-addr @ ;

\ : mk-reader ( list-tokens -- reader )
\   revlist>vector   2 cells allocate throw   tuck !  ( reader )
\   0 over cell+ ! ;

: +reader ( delta -- )
  dup    reader @ reader>c-addr +!
  negate reader @ reader>tail   +! ;

: eol? ( -- ? ) reader @ reader>tail @ 0= ;
: read-end ( -- c-addr ) >reader   reader @ reader>tail @   + ;


\ Scanning and tokenization ==================================================
: char-match ( c-addr u "name" --     X: ch -- ? )
    CREATE   dup c, 0 DO dup i + c@ c, LOOP drop align
  DOES> ( ch 'counted )
    count over + swap DO ( ch ) i c@ over = IF drop true UNLOOP EXIT THEN
    LOOP drop false ;


:noname S\"  \t\n\r,"   ; execute char-match space?
:noname S" [](){}'`~^@" ; execute char-match singleton?
:noname S\" ;,\q"       ; execute char-match non-symbol?

: skip-spaces ( -- ) BEGIN >reader c@ space? WHILE 1 +reader REPEAT ;

: ~@? ( -- ? ) >reader c@ [char] ~ =   >reader char+ c@ [char] @ =   and ;

: /token! ( u -- ) reader @ reader>len ! ;

VARIABLE backslash?

2 CONSTANT err-malformed-string

: end-token ( c-addr -- ) >reader - ( len ) reader @ reader>len ! ;

: string-token ( -- )
  backslash? off
  >reader char+ BEGIN \ Skip the initial quote
    dup c@ [char] \ = IF true backslash? !   char+ THEN
    dup c@ [char] " =   backslash? @ 0= and IF \ Real end of string
      char+ ( after-quote ) end-token
      EXIT THEN
    dup read-end >= IF err-malformed-string throw THEN
    backslash? off
    char+ \ Just keep advancing.
  AGAIN ;

\ Consumes the entire rest of the line.
: comment-token ( -- ) reader @ dup reader>tail @   swap reader>len ! ;

: basic-token ( -- )
  >reader BEGIN
    \ Check EOL
    >reader reader @ reader>tail @ + over <= IF end-token EXIT THEN
    \ Check if the current character is special or part of a number/symbol.
    dup c@ dup  singleton?
           over non-symbol? or
           swap space?      or   IF end-token EXIT THEN
    \ Keep consuming characters!
    char+
  AGAIN ;


\ Advances to the next token without returning it.
: +token ( -- )
  reader @ reader>len @ +reader \ Advance to after the previous token.
  skip-spaces                   \ Now pointed at the start of the next token.
  eol? IF EXIT THEN             \ Bail if we've run out of string.
  \ Special case for ~@ the only two-char small token.
  ~@? IF 2 /token! EXIT THEN
  >reader c@ singleton? IF 1 /token!     EXIT THEN
  >reader c@ [char] " = IF string-token  EXIT THEN
  >reader c@ [char] ; = IF comment-token EXIT THEN

  \ Base case: a number or symbol - continue until the next non-special token.
  basic-token ;

\ Returns the current token, without advancing the token.
: token ( -- c-addr u ) >reader   reader @ reader>len @ ;

: token+ ( -- c-addr u ) token +token ;

\ Builds a new tokenizer into the reader variable.
: tokenize ( c-addr u -- )
  3 cells allocate throw reader !
  reader @ reader>tail   !
  reader @ reader>c-addr !
  0 reader @ reader>len  !
  +token ;

: dump-tokens ( -- )
  cr BEGIN eol? 0= WHILE ." token: _" token+ type ." _" cr REPEAT cr ;


\ Reading Lisp values ========================================================
DEFER read-form

3 CONSTANT err-malformed-list
4 CONSTANT err-malformed-number

\ This non-tail recurses so that the return list can be generated correctly.
\ The current token is loaded and should be consumed. EOL is an error, ) should
\ return empty-list.
: read-list ( -- value )
  eol? IF err-malformed-list throw THEN
  token drop c@ [char] ) = IF +token empty-list EXIT THEN
  \ Otherwise, read a whole form, then recurse and cons them together.
  read-form recurse cons ;

\ -- Number readers ==========================================================
VARIABLE negated?

\ Inner number reader - parse using Forth's machinery, throw if not clean.
: (read-number) ( c-addr u -- number|0 )
  0 0 2swap >number ( ud c-addr u ) IF \ Incomplete parse!
    drop 2drop 0
  ELSE
    drop ( ud ) D>S
    negated? @ IF negate THEN
    number +token
  THEN ;

\ Starts out pointing at the 0x part. Skip that, then parse with base 16.
: read-hex     ( c-addr u -- number|0 )
  2 /string   base @ >R   hex      (read-number)   R> base ! ;
: read-binary  ( c-addr u -- number|0 )
  2 /string   base @ >R   2 base ! (read-number)   R> base ! ;

: read-decimal ( c-addr u -- number|0 ) (read-number) ;

: ?read-number ( c-addr u -- value -1 | 0 )
  negated? off
  dup 1 > IF \ Got enough characters to try parsing a prefix.
    over c@   '-' = IF 1 /string   negated? on THEN
  THEN
  \ TODO: Other bases?
  read-decimal ?dup ( value true | false ) ;

\ -- Other readers ===========================================================
\ Strip off the quotes and return as a string.
\ TODO: Handle escaping - the backslashes should be dropped as it's copied in.
: read-str-lit ( c-addr u -- string )
  1 /string   1-
  (unescape?) on
  >string   +token ;

\ Starts pointing at : but that's not part of the string, so move past it.
: read-keyword ( c-addr u -- keyword ) +token   1 /string >keyword ;

: read-vector  ( c-addr u -- vector )
  2drop empty-list +token
  BEGIN token drop c@ [char] ] <> WHILE ( list )
    read-form swap cons
  REPEAT ( list ) +token revlist>vector ;

DEFER [hash-map]

\ Maps are a special case - they parse as a list calling
\ (hash-map k1 v1 k2 v2 ...) to dynamically construct the map.
\ This is because the map can't really be built with unevaluated ASTs as keys,
\ unlike a vector or list.
\ TODO: This can be optimized to directly build a map if all the keys are
\ constants. But that's probably not worth the overhead to check. If this does
\ change, make sure to update eval-ast for maps.
: read-map ( c-addr u -- map )
  2drop empty-list +token
  BEGIN token drop c@ [char] } <> WHILE ( list )
    read-form
    \ ." key:   " dup pr-str type cr
    read-form ( list key value )
    \ ." value: " dup pr-str type cr
    rot cons cons ( list' )
  REPEAT +token S" hash-map" >symbol swap cons
  \ ." final: " dup pr-str type cr
  ;

\ Checks the special symbols: nil, true, false.
: ?named ( value c-addr u -- value -1 | )
  token str= IF +token -1 bail ELSE drop THEN ;

: ?named-value ( -- value -1 | 0 )
  nil       S" nil"   ?named
  mal-true  S" true"  ?named
  mal-false S" false" ?named
  0 ;

\ TODO: Various reader macros like @, ' and ~
: read-atom ( -- value )
  \ First check the things with obvious prefixes, like strings and keywords.
  token over c@ ( c-addr u ch )
  dup [char] " = IF drop read-str-lit EXIT THEN
  dup [char] : = IF drop read-keyword EXIT THEN
  dup [char] [ = IF drop read-vector  EXIT THEN
      [char] { = IF      read-map     EXIT THEN
  \ Numbers start with 0x or 0b, a digit, or -
  ?read-number IF EXIT THEN
  \ If we're still here, it looks like a symbol.
  ?named-value IF EXIT THEN
  token+ >symbol ;


\ Peeks the token to check if it starts with ( and calls read-list or read-atom.
:noname ( -- value )
  eol? IF nil EXIT THEN
  token drop c@ [char] ( = IF +token read-list ELSE read-atom THEN ;
IS read-form


: read-str-raw ( c-addr u -- value ) tokenize read-form ;

