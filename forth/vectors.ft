\ Vectors library for general Forths.
\ A vector is an immutable array in ALLOCATE'd memory.
\ It begins with a cell containing %VECTOR, then a cell containing the length, and
\ finally `length` cells holding the values.

CREATE empty-vector %vector , 0 ,

: v>len  ( vector -- 'length ) cell+ ;
: v>data ( vector -- a-addr )  2 cells + ;

: allocv ( len -- )
  dup 2 + cells allocate throw ( len a-addr )
  %vector over !
  2dup cell+ !
  nip ;

: countv ( vector -- length ) v>len @ ;

: vector? ( x -- vector? ) @ %vector = ;

\ Copies a vector's data cells to an arbitrary a-addr.
: copyv ( vector dest-addr -- )
  >R   dup v>data   swap countv   R> swap cells move ;

: atv   ( index vector -- a-addr ) v>data swap cells + ;

\ TODO: This is horribly inefficient, copying the vector repeatedly. This should
\ be smarter and more data-sharing, like a reversed tail list plus a vector.
: conj ( vector1 value -- vector2 )
  over countv 1+ allocv ( v1 value v2 )
  swap >R dup >R        ( v1 v2    R: value v2 )
  v>data copyv          ( R: value v2 )
  R> dup countv 1-      ( v2 last-index   R: value )
  over atv              ( v2 'slot        R: value )
  R> swap !             ( v2 ) ;

40 CONSTANT err-indexv

\ Throws if the index is out of range. Does nothing otherwise.
: ?indexv ( index vector -- index vector ) 2dup countv >= err-indexv and throw ;

: getv ( index vector -- value ) ?indexv   atv @ ;

\ Printer for vectors.
:noname ( vector -- )
  [CHAR] [ pinch
  dup countv 0 DO i IF space THEN   i over getv (pr-str) LOOP drop
  [CHAR] ] pinch ; %vector method-of (pr-str)
