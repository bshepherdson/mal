\ Lists library for general Forths.
\ A list is either NIL or a three-cell ALLOCATEd block containing
\ [ %LIST | head | tail ]

CREATE empty-list %LIST , 0 , 0 ,

: l>head ( list -- 'head ) cell+ ;
: l>tail ( list -- 'tail ) 2 cells + ;
: head   ( list -- head )  l>head @ ;

\ Deferring this because it needs to be made smarter once lazy seqs are loaded.
DEFER tail
:noname ( list -- tail )  l>tail @ ; IS tail

: list?   ( x -- list? ) @ %list = ;
: emptyl? ( list -- ? ) empty-list = ;

: countl ( list -- length )
  0 BEGIN over emptyl? 0= WHILE 1+ >R tail R> REPEAT nip ;

\ : allocl ( -- ) 3 cells allocate throw
\   %list over !
\   nil over l>head !
\   nil over l>tail ! ;

: cons ( head tail -- list )
  3 cells allocate throw >R
  %list R@ !
  R@ l>tail !
  R@ l>head !
  R> ;

: second ( list -- value ) tail head ;
: third  ( list -- value ) tail tail head ;

: reverse ( list1 -- list2 )
  empty-list BEGIN over emptyl? 0= WHILE over head swap cons >R tail R> REPEAT nip ;

: revlist>vector ( list -- vector )
  dup countl allocv swap ( vector list )
  over countv ?dup 0= IF drop EXIT THEN ( vector list count )
  1- 0 swap DO \ I is the index ( vector list )
    2dup head i rot atv ! ( vector list )
    tail
  -1 +LOOP drop ;

: vec>list ( vec -- list )
  empty-list   swap dup >R countv   ( dst len   R: src )
  BEGIN dup WHILE   ( dst i+1       R: src )
    1- tuck R@ getv ( i dst value   R: src )
    swap cons swap  ( dst' i        R: src )
  REPEAT R> 2drop ; ( list )

: >vector ( list -- vector )
  dup emptyl? IF drop empty-vector EXIT THEN
  dup countl dup allocv >R   ( list len         R: vector )
  cells R@ v>data            ( list size data   R: vector )
  tuck + swap                ( list top start   R: vector )
  DO dup head i !   tail   1 cells +LOOP drop R> ;

: >list ( list|vec -- list )
  dup list? IF EXIT THEN
  dup vector? IF vec>list ELSE
  dup % %lazy-seq = IF EXIT ELSE
  ." >list unknown type: " % . cr 200 throw THEN THEN ;

\ Seq ( list -- seq )
\ The function takes no arguments, and closes over xs, the list.
\ The function is (cons (head xs) (lazy-seq (tail xs)))
\ Except that lazy-seq is a macro, so it's really written as
\   (def! list-seq
\     (fn* []
\       (cons (head xs) (lazy (quote (tail xs))))))
\ This is deferred so it can be constructed later.
\ DEFER list-seq
\ :noname ( list -- lazy-seq ) list-seq ; %list method-of seq

\ Printing
: (pr-spaced-each) ( index value -- index' )
  over IF bl pinch THEN   (pr-str)   1+ ;

:noname [char] ( pinch   0 ['] (pr-spaced-each) rot each drop   [char] ) pinch ;
  %list method-of (pr-str)

\ Eval
:noname ( env list -- list' )
  \ Copy the list, EVAL-ing everything in it on the way through.
  \ Make sure to get "applicative" order by EVALing head before recursing.
  \ This puts a burden on both stacks, but it can't be avoided without copying.
  dup emptyl? IF nip EXIT THEN \ Bail when we hit the empty list.
  2dup head          ( env list env head )
  EVAL               ( env list new-head )
  -rot tail recurse  ( new-head new-tail )
  cons               ( list' ) ;                %list method-of eval-ast


:noname countl number ;   %list method-of mal-count

\ Compare
:noname ( x y -- -1|0|1 )
  %?cmp BEGIN
    over emptyl? over emptyl? and IF 2drop 0 EXIT THEN
    over emptyl? IF 2drop -1 EXIT THEN
    dup  emptyl? IF 2drop  1 EXIT THEN
    over head over head compare ?dup IF >R 2drop R> EXIT THEN
    tail swap tail swap
  AGAIN ; %list method-of compare

:noname ( ... list -- ... )
  \ ." (each): " hex.s   4 spaces   dup % . cr
  \ ." %list (each)" cr
  depth >R
  BEGIN dup emptyl? 0= WHILE
    \ 8 spaces hex.s cr
    dup >R   head (each-xt) @ execute   R> tail
  REPEAT drop
  depth R> 1- <> 201 and throw
  \ ." (each) end: " hex.s cr
  ; %list method-of (each)
