\ Lists library for general Forths.
\ A list is either NIL or a three-cell ALLOCATEd block containing
\ [ %LIST | head | tail ]

CREATE empty-list %LIST , 0 , 0 ,

: l>head ( list -- 'head ) cell+ ;
: l>tail ( list -- 'tail ) 2 cells + ;
: head   ( list -- head )  l>head @ ;
: tail   ( list -- tail )  l>tail @ ;

: list?   ( x -- list? ) @ %list = ;
: emptyl? ( list -- ? ) empty-list = ;

: countl ( list -- length )
  0 BEGIN over emptyl? 0= WHILE 1+ >R tail R> REPEAT nip ;

\ : allocl ( -- ) 3 cells allocate throw
\   %list over !
\   nil over l>head !
\   nil over l>tail ! ;

: cons ( head tail -- list )
  3 cells allocate throw >R
  %list R@ !
  R@ l>tail !
  R@ l>head !
  R> ;

: second ( list -- value ) tail head ;
: third  ( list -- value ) tail tail head ;

: reverse ( list1 -- list2 )
  empty-list BEGIN over emptyl? 0= WHILE over head swap cons >R tail R> REPEAT nip ;

: revlist>vector ( list -- vector )
  dup countl allocv swap ( vector list )
  over countv ?dup 0= IF drop EXIT THEN ( vector list count )
  1- 0 swap DO \ I is the index ( vector list )
    2dup head i rot atv ! ( vector list )
    tail
  -1 +LOOP drop ;

\ Sequence
\ Seq ( list -- seq )
\ List seqs are easy - just a pointer to the list. But return nil if empty.
:noname
  dup emptyl? IF drop nil EXIT THEN
  %list-seq 2 alloc-typed ( list seq )
  tuck cell+ ! ; %list method-of seq

\ First ( list-seq -- value )
:noname cell+ @ head ; %list-seq method-of first
\ Rest  ( list-seq -- list-seq )
:noname cell+ @ tail seq ; %list-seq method-of rest
\ NOTE: If the tail is the empty list, seq on it will return nil.

: lseq>list ( list-seq -- list ) cell+ @ ;

\ Printing
: (pr-list-each) ( index value -- index' )
  over IF bl pinch THEN   (pr-str)   1+ ;

:noname ( list -- )
  [CHAR] ( pinch   0 ['] (pr-list-each) rot each drop   [CHAR] ) pinch ;
%list method-of (pr-str)

\ Eval
:noname ( env list -- list' )
  \ Copy the list, EVAL-ing everything in it on the way through.
  \ Make sure to get "applicative" order by EVALing head before recursing.
  \ This puts a burden on both stacks, but it can't be avoided without copying.
  dup emptyl? IF nip EXIT THEN \ Bail when we hit the empty list.
  2dup head          ( env list env head )
  EVAL               ( env list new-head )
  -rot tail recurse  ( new-head new-tail )
  cons               ( list' ) ;                %list method-of eval-ast


:noname countl number ;   %list method-of mal-count

\ Compare
:noname ( x y -- -1|0|1 )
  %?cmp   seq swap seq swap   compare ; %list method-of compare

:noname ( x y -- -1|0|1 )
  %?cmp
  BEGIN over some? over some? and WHILE
    over first over first compare ?dup IF >R 2drop R> EXIT THEN
    rest swap rest swap
  REPEAT 2drop 0 ; %list-seq method-of compare
