\ Lists library for general Forths.
\ A list is either NIL or a three-cell ALLOCATEd block containing
\ [ %LIST | head | tail ]

CREATE empty-list %LIST , 0 , 0 ,

: l>head ( list -- 'head ) cell+ ;
: l>tail ( list -- 'tail ) 2 cells + ;
: head   ( list -- head )  l>head @ ;
: tail   ( list -- tail )  l>tail @ ;

: list?   ( x -- list? ) @ %list = ;
: emptyl? ( list -- ? ) empty-list = ;

: countl ( list -- length )
  0 BEGIN over emptyl? 0= WHILE 1+ >R tail R> REPEAT nip ;

\ : allocl ( -- ) 3 cells allocate throw
\   %list over !
\   nil over l>head !
\   nil over l>tail ! ;

: cons ( head tail -- list )
  3 cells allocate throw >R
  %list R@ !
  R@ l>tail !
  R@ l>head !
  R> ;

: first  ( list -- value ) head ;
: second ( list -- value ) tail head ;
: third  ( list -- value ) tail tail head ;

: reverse ( list1 -- list2 )
  empty-list BEGIN over emptyl? 0= WHILE over head swap cons >R tail R> REPEAT nip ;

: revlist>vector ( list -- vector )
  dup countl allocv swap ( vector list )
  over countv ?dup 0= IF drop EXIT THEN ( vector list count )
  1- 0 swap DO \ I is the index ( vector list )
    2dup head i rot atv ! ( vector list )
    tail
  -1 +LOOP drop ;

\ Each
VARIABLE (eachl-xt)
:noname ( ... xt list -- )
  swap (eachl-xt) >var< >R   ( list    R: old-xt )
  BEGIN dup emptyl? 0= WHILE
    dup >R   head   (eachl-xt) @ execute   R> tail
  REPEAT drop   R> (eachl-xt) ! ;   %list method-of each

\ Printing
: (pr-list-each) ( index value -- index' )
  over IF bl pinch THEN   (pr-str)   1+ ;

:noname ( list -- )
  [CHAR] ( pinch   0 ['] (pr-list-each) rot each drop   [CHAR] ) pinch ;
%list method-of (pr-str)

\ Eval
:noname ( env list -- list' )
  \ Copy the list, EVAL-ing everything in it on the way through.
  \ Make sure to get "applicative" order by EVALing head before recursing.
  \ This puts a burden on both stacks, but it can't be avoided without copying.
  dup emptyl? IF nip EXIT THEN \ Bail when we hit the empty list.
  2dup head          ( env list env head )
  EVAL               ( env list new-head )
  -rot tail recurse  ( new-head new-tail )
  cons ; %list method-of eval-ast

