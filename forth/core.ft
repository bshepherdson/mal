\ REPL environment ===========================================================
VARIABLE repl-env

nil new-env repl-env !

: builtin: ( xt "name" -- )
  builtin   parse-name >symbol swap   repl-env @ env-set   repl-env ! ;

\ Forth Helpers ==============================================================
\ Calls xt ( acc x -- acc' ) repeatedly for each element of the list.
: reduce ( list zero xt -- result )
  >R BEGIN over emptyl? 0= WHILE ( list acc )
    over head R@ execute ( list acc' )
    swap tail swap
  REPEAT nip R> drop ;

\ Expects a length-2 list and calls xt with the two inner values: ( a b -- result )
: bin-arithmetic ( list xt -- result )
  >R dup head num-value   swap tail head num-value   R> execute number ;

\ Builtins ===================================================================
\ Builtins all take their args as a Mal list.

\ -- Arithmetic ==============================================================
\ +
: [+] ( acc number -- acc' ) num-value + ;
:noname ( argv -- number ) 0   ['] [+]   reduce number ; builtin: +
\ *
: [*] ( acc number -- acc' ) num-value * ;
:noname ( argv -- number ) 1   ['] [*]   reduce number ; builtin: *

\ -
:noname ( argv -- number ) ['] - bin-arithmetic        ; builtin: -
\ /   - Using Forth's integer division.
:noname ( argv -- number ) ['] / bin-arithmetic        ; builtin: /

\ -- Construction ============================================================
\ (hash-map k1 v1 k2 v2 ...)
: [hash-map1] ( map list -- map' )
  dup emptyl? IF drop EXIT THEN
  dup head swap tail dup tail >R ( map head list+1   R: list+2 )
  head rot assoc ( map'   R: list+2 )
  R> ;

:noname empty-map swap BEGIN dup emptyl? 0= WHILE
  dup head swap tail dup tail >R ( map head list+1   R: list+2 )
  head rot assoc ( map'   R: list+2 )
  R> REPEAT ( map empty ) drop                         ; builtin: hash-map
