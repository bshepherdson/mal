\ REPL environment ===========================================================
VARIABLE repl-env

nil new-env repl-env !

\ The REPL env always contains *ARGV*, which is an empty list by default.
\ These are only populated when running in the scripting mode.
S" *ARGV*" >symbol empty-list repl-env @ env-set repl-env !

: builtin: ( xt "name" -- )
  builtin   parse-name >symbol swap   repl-env @ env-set   repl-env ! ;

\ Forth Helpers ==============================================================
\ Calls xt ( acc x -- acc' ) repeatedly for each element of the list.
: reduce ( list zero xt -- result )
  >R BEGIN over emptyl? 0= WHILE ( list acc )
    over head R@ execute ( list acc' )
    swap tail swap
  REPEAT nip R> drop ;

\ Expects a length-2 list and calls xt with the two inner values: ( a b -- result )
: bin-arithmetic ( list xt -- result )
  >R dup head num-value   swap tail head num-value   R> execute number ;

\ Builtins all take their args as a Mal list.
\ Arithmetic =================================================================
\ +
: [+] ( acc number -- acc' ) num-value + ;
:noname ( argv -- number ) 0   ['] [+]   reduce number ; builtin: +
\ *
: [*] ( acc number -- acc' ) num-value * ;
:noname ( argv -- number ) 1   ['] [*]   reduce number ; builtin: *

\ -
:noname ( argv -- number ) ['] - bin-arithmetic        ; builtin: -
\ /   - Using Forth's integer division.
:noname ( argv -- number ) ['] / bin-arithmetic        ; builtin: /

\ Comparisons ================================================================
\ =
:noname ( argv -- bool )
  dup head swap second compare 0= >bool                ; builtin: =

: bin-cmp ( argv xt -- bool )
  >R dup head num-value swap second num-value R> execute >bool ;

\ < <= > >=
:noname ['] <  bin-cmp                                 ; builtin: <
:noname ['] <= bin-cmp                                 ; builtin: <=
:noname ['] >  bin-cmp                                 ; builtin: >
:noname ['] >= bin-cmp                                 ; builtin: >=

\ Strings and Printing =======================================================
VARIABLE (sep)
: (noop) ;
: (prn-space) bl pinch ;

: (sep-none!)  ['] (noop)      (sep) ! ;
: (sep-space!) ['] (prn-space) (sep) ! ;

(sep-none!)

: (pr-str-each) ( cnt x -- cnt' ) over IF (sep) @ execute THEN   (pr-str)   1+ ;

: [pr-str] ( list -- c-addr u )
  prn0
  0 ['] (pr-str-each) rot each
  drop prn>str ;

\ (pr-str & args)
:noname ( argv -- string )
  print-readably? on   (sep-space!)   [pr-str] >string     ; builtin: pr-str

\ (str & args)
:noname ( argv -- str )
  print-readably? off   (sep-none!)   [pr-str] >string     ; builtin: str

\ (prn & args)
:noname ( argv -- str )
  print-readably? on   (sep-space!)   [pr-str] type cr nil ; builtin: prn

\ (println & args)
:noname
  print-readably? off  (sep-space!)   [pr-str] type cr nil ; builtin: println

\ Files ======================================================================
\ (read-string string)
:noname ( argv -- form ) head s>str read-str-raw        ; builtin: read-string

\ (slurp "filename")
:noname ( argv -- string )
  head s>str r/o open-file throw >R ( R: fileid )
  R@ file-size throw D>S            ( len  R: fileid )
  dup 2 cells + allocate throw      ( len string   R: fileid )
  %string over !   tuck s>len !     ( string       R: fileid )
  dup s>str R@ read-file throw drop ( string       R: fileid )
  R> close-file throw               ( string )          ; builtin: slurp

\ (eval form)
:noname ( argv -- value ) head repl-env @ swap EVAL     ; builtin: eval

\ Atoms ======================================================================
\ (atom value)
:noname ( argv -- atom ) head new-atom                  ; builtin: atom
\ (atom? x)
:noname ( argv -- atom ) head % %atom = >bool           ; builtin: atom?
\ (deref atom)
:noname ( argv -- atom ) head deref                     ; builtin: deref
\ (reset! atom value)
:noname ( argv -- value )
  dup second dup rot head ( val val atom ) set-atom!    ; builtin: reset!

\ (swap! atom f ...args)
:noname ( argv -- value )
  dup head dup >R           ( argv atom     R: atom )
  deref over tail tail cons ( argv args )
  swap second               ( args f )
  swap cons                 ( call )
  (builtin-env) @ swap EVAL ( new-value )
  dup R> set-atom!          ( new-value )               ; builtin: swap!

\ Lists ======================================================================
\ (list & contents)
:noname                                                 ; builtin: list

\ (list? x)
:noname head list? >bool                                ; builtin: list?

\ (empty? x)
:noname head seq nil? >bool                             ; builtin: empty?

\ (count x)
:noname head mal-count                                  ; builtin: count


\ Construction ===============================================================
\ (hash-map k1 v1 k2 v2 ...)
: [hash-map1] ( map list -- map' )
  dup emptyl? IF drop EXIT THEN
  dup head swap tail dup tail >R ( map head list+1   R: list+2 )
  head rot assoc ( map'   R: list+2 )
  R> ;

:noname empty-map swap BEGIN dup emptyl? 0= WHILE
  dup head swap tail dup tail >R ( map head list+1   R: list+2 )
  head rot assoc ( map'   R: list+2 )
  R> REPEAT ( map empty ) drop                         ; builtin: hash-map

\ -- Debugging ===============================================================
\ (env)
:noname drop repl-env @                                ; builtin: env
\ (sum coll)
:noname seq first   0 ['] [+]   rot each   number      ; builtin: sum
\ (quit x)
:noname head quit                                      ; builtin: quit
