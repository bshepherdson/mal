\ REPL environment ===========================================================
VARIABLE repl-env

nil new-env repl-env !

\ The REPL env always contains *ARGV*, which is an empty list by default.
\ These are only populated when running in the scripting mode.
S" *ARGV*" >symbol empty-list repl-env @ env-set repl-env !

: builtin: ( xt "name" -- )
  builtin   parse-name >symbol swap   repl-env @ env-set   repl-env ! ;

\ Forth Helpers ==============================================================
\ Calls xt ( acc x -- acc' ) repeatedly for each element of the list.
: reduce ( list zero xt -- result )
  >R BEGIN over emptyl? 0= WHILE ( list acc )
    over head R@ execute ( list acc' )
    swap tail swap
  REPEAT nip R> drop ;

\ Expects a length-2 list and calls xt with the two inner values: ( a b -- result )
: bin-arithmetic ( list xt -- result )
  >R dup head num-value   swap tail head num-value   R> execute number ;

\ Builtins all take their args as a Mal list.
\ Arithmetic =================================================================
\ +
: [+] ( acc number -- acc' ) num-value + ;
:noname ( argv -- number ) 0   ['] [+]   reduce number ; builtin: +
\ *
: [*] ( acc number -- acc' ) num-value * ;
:noname ( argv -- number ) 1   ['] [*]   reduce number ; builtin: *

\ -
:noname ( argv -- number ) ['] - bin-arithmetic        ; builtin: -
\ /   - Using Forth's integer division.
:noname ( argv -- number ) ['] / bin-arithmetic        ; builtin: /

\ Comparisons ================================================================
\ =
:noname ( argv -- bool )
  dup head swap second compare 0= >bool                ; builtin: =

: bin-cmp ( argv xt -- bool )
  >R dup head num-value swap second num-value R> execute >bool ;

\ < <= > >=
:noname ['] <  bin-cmp                                 ; builtin: <
:noname ['] <= bin-cmp                                 ; builtin: <=
:noname ['] >  bin-cmp                                 ; builtin: >
:noname ['] >= bin-cmp                                 ; builtin: >=

\ Strings and Printing =======================================================
VARIABLE (sep)
: (noop) ;
: (prn-space) bl pinch ;

: (sep-none!)  ['] (noop)      (sep) ! ;
: (sep-space!) ['] (prn-space) (sep) ! ;

(sep-none!)

: (pr-str-each) ( cnt x -- cnt' ) over IF (sep) @ execute THEN   (pr-str)   1+ ;

: [pr-str] ( list -- c-addr u )
  prn0
  0 ['] (pr-str-each) rot each
  drop prn>str ;

\ (pr-str & args)
:noname ( argv -- string )
  print-readably? on   (sep-space!)   [pr-str] >string     ; builtin: pr-str

\ (str & args)
:noname ( argv -- str )
  print-readably? off   (sep-none!)   [pr-str] >string     ; builtin: str

\ (prn & args)
:noname ( argv -- str )
  print-readably? on   (sep-space!)   [pr-str] type cr nil ; builtin: prn

\ (println & args)
:noname
  print-readably? off  (sep-space!)   [pr-str] type cr nil ; builtin: println

\ Files ======================================================================
\ (read-string string)
:noname ( argv -- form ) head s>str read-str-raw        ; builtin: read-string

\ (slurp "filename")
:noname ( argv -- string )
  head s>str r/o open-file throw >R ( R: fileid )
  R@ file-size throw D>S            ( len  R: fileid )
  dup 2 cells + allocate throw      ( len string   R: fileid )
  %string over !   tuck s>len !     ( string       R: fileid )
  dup s>str R@ read-file throw drop ( string       R: fileid )
  R> close-file throw               ( string )          ; builtin: slurp

\ (eval form)
:noname ( argv -- value ) head repl-env @ swap EVAL     ; builtin: eval

\ Atoms ======================================================================
\ (atom value)
:noname ( argv -- atom ) head new-atom                  ; builtin: atom
\ (atom? x)
:noname ( argv -- atom ) head % %atom = >bool           ; builtin: atom?
\ (deref atom)
:noname ( argv -- atom ) head deref                     ; builtin: deref
\ (reset! atom value)
:noname ( argv -- value )
  dup second dup rot head ( val val atom ) set-atom!    ; builtin: reset!

\ (swap! atom f ...args)
:noname ( argv -- value )
  dup head dup >R           ( argv atom     R: atom )
  deref over tail tail cons ( argv args )
  swap second               ( args f )
  swap cons                 ( call )
  (builtin-env) @ swap EVAL ( new-value )
  dup R> set-atom!          ( new-value )               ; builtin: swap!

\ Lists ======================================================================
\ (list & contents)
:noname                                                 ; builtin: list

\ (list? x)
:noname head list? >bool                                ; builtin: list?

\ (count x)
:noname head ." Count: " dup . dup % . dup pr-str type mal-count 4 spaces dup . dup pr-str type cr ; builtin: count

\ (empty? x)
:noname head mal-count 0= >bool                         ; builtin: empty?

\ (cons x xs)
:noname dup head swap second >list cons                 ; builtin: cons

\ (>list ls)
:noname head >list                                      ; builtin: >list

\ (head ls)   TODO: Blindly assumes a list! Fix this.
:noname head head                                       ; builtin: head
\ (tail ls)   TODO: Blindly assumes a list! Fix this.
:noname head tail                                       ; builtin: tail

\ (concat & lists)
\ TODO: Make this use lazy seqs when those exist.
: [concat1] ( heads... list big-tail -- l3 )
  \ If 'list' (the one we're currently unrolling) is empty, drop it and start returning.
  over emptyl? IF nip EXIT THEN
  \ Otherwise, unwrap a cell and recurse.
  swap dup head swap tail rot ( heads... head tail big-tail )
  recurse ( heads... tail ) cons ;

\ : [concat] ( heads... tail -- l )
\   dup emptyl? IF EXIT THEN
\   dup head swap tail ( lists... tail )
\   RECURSE            ( lists... list catted )
\   [concat1]          ( lists... catted ) ;

:noname ( heads... tail -- l )
  dup emptyl? IF drop empty-list EXIT THEN
  dup head >list swap tail ( lists... tail )
  RECURSE                  ( lists... list catted )
  [concat1]                ( lists... catted )          ; builtin: concat

\ Vectors ====================================================================
\ (nth vec i)
:noname ( vec i -- value )
  dup second num-value   swap head getv                 ; builtin: nth

\ (vector? x)
:noname ( x -- bool ) head vector? >bool                ; builtin: vector?

\ TODO: vec and vector - in Mal?

\ Construction ===============================================================
\ (hash-map k1 v1 k2 v2 ...)
: [hash-map1] ( map list -- map' )
  dup emptyl? IF drop EXIT THEN
  dup head swap tail dup tail >R ( map head list+1   R: list+2 )
  head rot assoc ( map'   R: list+2 )
  R> ;

:noname empty-map swap BEGIN dup emptyl? 0= WHILE
  dup head swap tail dup tail >R ( map head list+1   R: list+2 )
  head rot assoc ( map'   R: list+2 )
  R> REPEAT ( map empty ) drop                         ; builtin: hash-map

\ (vector xs...)
:noname ( xs -- vector ) >vector                       ; builtin: vector
\ (vec x)
:noname ( x -- vector ) head >vector                   ; builtin: vec

\ :noname ( fn -- seq ) head lazy-seq                    ; builtin: lazy

\ -- Debugging ===============================================================
\ (env)
:noname drop repl-env @                                ; builtin: env
\ (quit x)
:noname head quit                                      ; builtin: quit
