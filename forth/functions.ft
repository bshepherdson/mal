\ Functions ==================================================================
\ [ %builtin  | xt ]
\ [ %function | env | params | body ]

: builtin ( xt -- fn )
  %builtin 2 alloc-typed >R
  R@ cell+ !
  nil R@ 2 cells + !
  nil R@ 3 cells + !
  R> ;

: f>env    cell+ ;
: f>params 2 cells + ;
: f>body   3 cells + ;

: function ( env params body -- fn )
  %function 4 alloc-typed >R
  R@ f>body   !
  R@ f>params !
  R@ f>env    !
  R> ;

: function? ( value -- ? ) % %function = ;
: builtin?  ( value -- ? ) % %builtin  = ;
: fn? ( value -- ? ) dup function? swap builtin? or ;

: exec-function ( env args function -- env' form )
  \ Need to create a new environment for the function, which descends from the
  \ closed environment with the params and arguments layered on top.
  rot drop
  dup >R   f>env @ swap  ( closure-env args          R: fn )
  R@ f>params @ swap     ( closure-env params args   R: fn )
  env-zipping            ( env   R: fn )
  R> f>body @            ( env body ) ;

VARIABLE (builtin-env)
: exec-builtin  ( env args builtin  -- env result )
  2 pick (builtin-env) !
  cell+ @ execute ;

\ To support TCO, this returns a break? flag, either true to indicate the result is
\ fully evaluated, or false if we're set up for tail recursion.
: exec-fn ( env args fn -- env form|result break? )
  dup builtin? IF exec-builtin true ELSE exec-function false THEN ;

:noname drop S" #<builtin>"  prn-type ; %builtin  method-of (pr-str)
:noname drop S" #<function>" prn-type ; %function method-of (pr-str)
