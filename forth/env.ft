\ Environments wrap a map with an "outer" pointer to another Env.
\ [ %env | map | outer ]
: alloce  ( -- ) %env 3 alloc-typed ;

: e>map   cell+ ;
: e>outer 2 cells + ;

: new-env ( outer -- env )
  alloce   empty-map over e>map ! ( outer env )   tuck e>outer ! ;

: env-set ( key-sym value env -- env' )
  \ ." Binding: " 2 pick pr-str type   ."  to " over pr-str type cr
  dup >R   e>map @ assoc   R> tuck e>map ! ;

\ env-find returns nil if it isn't found. env-get throws if not found.
\ (env-find) is an internal helper; it returns host 0 if not found.
: (env-find) ( key-sym env -- value|0 )
  dup nil? IF 2drop 0 EXIT THEN
  2dup   0 -rot e>map @ get-or   ( key-sym env value|0 )
  ?dup IF >R 2drop R> EXIT THEN  ( key-sym env )
  e>outer @ recurse ;

: env-find ( key-sym env -- value|nil ) (env-find) ?dup 0= IF nil THEN ;

7 CONSTANT err-not-found
VARIABLE (last-get)

: env-get ( key-sym env -- value )
  \ ." env-get " over pr-str type 4 spaces dup pr-str type cr
  over (last-get) !
  (env-find)   dup 0= err-not-found and throw ;

\ Construction ===============================================================
VARIABLE (bind-key)

: (let-bind) ( env key|value -- env' )
  (bind-key) @ IF \ Have a key, bind to this value after EVALing it.
    over >R EVAL R> ( value-eval'd env )
    (bind-key) @ -rot ( k v env )
    env-set
    0 (bind-key) !
  ELSE \ This is the key, just save it.
    (bind-key) !
  THEN ;

: env-binding ( env1 bindings -- env2 )
  \ Bindings might be a vector or a list; abstract it with each.
  0 (bind-key) >var< >R
  ['] (let-bind) swap each
  R> (bind-key) ! ;


\ Printing
:noname ( env -- )
  ." Env: "
  0 swap BEGIN dup some? WHILE
    over IF S"  -> " prn-type THEN
    dup e>map @ (pr-str)
    e>outer @
    swap 1+ swap
  REPEAT 2drop ;                 %env method-of (pr-str)
