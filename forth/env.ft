\ Environments wrap a map with an "outer" pointer to another Env.
\ [ %env | map | outer ]
: alloce  ( -- ) %env 3 alloc-typed ;

: e>map   cell+ ;
: e>outer 2 cells + ;

: new-env ( outer -- env )
  alloce   empty-map over e>map ! ( outer env )   tuck e>outer ! ;

: env-set ( key-sym value env -- env' )
  dup >R   e>map @ assoc   R> tuck e>map ! ;

\ Find returns nil if it isn't found. Get throws if not found.
: env-find ( key-sym env -- value|nil )
  dup nil? IF 2drop nil EXIT THEN
  2dup e>map @ get   dup some? IF >R 2drop R> EXIT THEN
  drop ( key-sym env ) e>outer @ recurse ;

7 CONSTANT err-not-found
VARIABLE (last-get)

: env-get ( key-sym env -- value )
  \ ." env-get " over pr-str type 4 spaces dup pr-str type cr
  over (last-get) !
  env-find dup nil? IF drop err-not-found throw THEN ;

\ Construction ===============================================================
VARIABLE (bind-key)

: (let-bind) ( env key|value -- env' )
  (bind-key) @ IF \ Have a key, bind to this value after EVALing it.
    over >R EVAL R> ( value-eval'd env )
    (bind-key) @ -rot ( k v env )
    env-set
    0 (bind-key) !
  ELSE \ This is the key, just save it.
    (bind-key) !
  THEN ;

: env-binding ( env1 bindings -- env2 )
  \ Bindings might be a vector or a list; abstract it with each.
  0 (bind-key) >var< >R
  ['] (let-bind) swap each
  R> (bind-key) ! ;


: variadic ( keys=[& args] values=[...] )
  swap rest first swap
  dup some? IF lseq>list ELSE drop empty-list THEN
  ( args [vals...] ) ;

CREATE &-symbol %symbol , 1 , '&' c, align

: env-zipping ( env1 keys values -- env2 )
  seq swap seq swap rot      ( seq-keys seq-values env )
  new-env >R
  BEGIN over some? WHILE     ( seq-keys seq-values   R: env )
    over first
    \ Special case for a key of & to do variadic args.
    dup &-symbol equal? IF drop variadic R> env-set EXIT THEN
    over first
    R> env-set >R
    rest swap rest swap
  REPEAT 2drop R> ;


\ Printing
:noname ( env -- )
  ." Env: "
  0 swap BEGIN dup some? WHILE
    over IF S"  -> " prn-type THEN
    dup e>map @ (pr-str)
    e>outer @
    swap 1+ swap
  REPEAT 2drop ;                 %env method-of (pr-str)
