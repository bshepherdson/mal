\ Environments wrap a map with an "outer" pointer to another Env.
\ [ %env | map | outer ]
: alloce  ( -- ) %env 3 alloc-typed ;

: e>map   cell+ ;
: e>outer 2 cells + ;

: new-env ( outer -- env )
  alloce   empty-map over e>map ! ( outer env )   tuck e>outer ! ;

: env-set ( key-sym value env -- env' )
  dup >R   e>map @ assoc   R> tuck e>map ! ;

\ Find returns nil if it isn't found. Get throws if not found.
: env-find ( key-sym env -- value|nil )
  dup nil? IF 2drop nil EXIT THEN
  2dup e>map @ get   dup some? IF >R 2drop R> EXIT THEN
  drop ( key-sym env ) e>outer @ recurse ;

7 CONSTANT err-not-found

: env-get ( key-sym env -- value )
  env-find dup nil? IF drop err-not-found throw THEN ;

\ Printing
:noname ( env -- )
  ." Env: "
  0 swap BEGIN dup some? WHILE
    over IF ." -> " THEN
    dup e>map @ (pr-str) cr
    e>outer @   swap 1+ swap
  REPEAT 2drop ;                 %env method-of (pr-str)
