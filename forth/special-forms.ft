\ Special forms are checked in EVAL, they're not regular symbols.

\ Each special form has a symbol it matches against; they can go in a map or
\ environment.
VARIABLE special-forms
nil new-env special-forms !

\ Repeatedly matches special forms until none matches.
\ Returns the original env and list if no special form matches.
: ?special-form ( env list -- env' list' eval-done? )
    dup head special-forms @ env-find  ( env list value )
    dup some? IF execute ELSE drop false THEN ( env' list' eval-done? ) ;

: special-form: ( xt "name" -- )
  parse-name >symbol swap   special-forms @ env-set   special-forms ! ;

\ NOTE: Special forms take the entire list, not just the arguments.

\ START HERE: Add the done flag to all the special forms!

\ TODO: I'm not certain what def! is supposed to return. I settled on the value.
\ (def! sym value) ===========================================================
:noname ( env list -- env' nil done=T )
  2dup third eval ( env list value )
  dup >R   swap second swap ( env key value    R: value )
  \ We actually want to def into the REPL env, not the current one.
  repl-env @ env-set ( dyn-env repl-env'   R: value )
  drop R>   true ; special-form: def!

\ (let* (binding value ...) body) ============================================
:noname ( env list -- env' body-result )
  \ Create a new environment for the let bindings, descending from the input.
  swap new-env       ( list let-env )
  over second        ( list let-env binding-list )
  env-binding        ( list bound-env )
  swap third ;       ( bound-env body )             special-form: let*

\ (do body...) ===============================================================
:noname ( env list -- env' last-result )
  \ This loop ends one early to enable TCO.
  tail   dup emptyl? IF drop nil EXIT THEN
  BEGIN dup tail emptyl? 0= WHILE ( env body )
    2dup head EVAL drop  ( env body )
    tail
  REPEAT head ( env final-ast ) ;                  special-form: do

\ (if cond true false)
:noname ( env list -- env' result )
  tail   dup tail >R    ( env l-cond   R: l-true )
  2dup head EVAL nip    ( env result   R: l-true )
  R> swap               ( env l-true result )
  dup nil? swap   mal-false = or IF tail THEN \ Falsy case ( env list )
  dup emptyl? IF drop nil ELSE head THEN
  ( env ast ) ; special-form: if

\ (fn* (params)|[params] body)
:noname ( env list -- env' fn )
  over swap    ( env env list )
  dup second   ( env env list params )
  swap third   ( env env params body )
  function     ( env fn ) ;                         special-form: fn*

\ (quote form) ===============================================================
:noname ( env list -- env' form )
  second   skip-eval on ;                           special-form: quote

\ (quasiquote form)
DEFER [qq]

: sym= ( symbol c-addr u -- ? )
  rot   dup % %symbol <> IF drop 2drop false EXIT THEN
  s>str str= ;

: splice-unquote? ( ast -- ? )
  dup list? 0= IF drop false EXIT THEN
  head S" splice-unquote" sym= ;

: [qq-list] ( ast-list -- list )
  dup emptyl? IF EXIT THEN
  dup head swap tail recurse ( heads... head tail-list )

  ( heads... head tail-list )
  swap dup splice-unquote? IF ( heads... tail-list head )
    \ Combine with concat
    second  swap empty-list cons cons ( heads... elt+tail-list)
    'concat swap cons                 ( heads... [concat elt tail] )
  ELSE
    \ Combine with cons
    [qq] swap ( elt tail ) empty-list cons cons   'cons swap cons
  THEN ;

\ Converts the vector to a list, quasiquotes that, and wraps the result with `vec`.
\ TODO: The Mal tests are weird for this. The guide doc says that a QQ'd
\ vector should be wrapped with `(vec ...)` and so return a vector.
\ But the tests expect a list. Fix this on graduation.
: [qq-vector] ( vector -- form )
  >list [qq-list] ( qq'd-list ) ;
  \ empty-list cons
  \ 'vec swap cons ( [vec qq'd-list] )

:noname ( form -- form' )
  dup vector? IF [qq-vector] EXIT THEN
  dup list? IF
    dup head S" unquote" sym= IF second ELSE [qq-list] THEN
    EXIT
  THEN
  \ Maps and symbols are wrapped with (quote x) to avoid evaluating them.
  dup % dup %map =   swap %symbol = or IF
    empty-list cons   'quote swap cons EXIT THEN ; IS [qq]
  \ Everything else is returned unchanged.

:noname ( env list -- env' form )
  second [qq] ( 2dup EVAL nip )   ;           special-form: quasiquote

\ Macros =====================================================================
:noname ( env list -- env' form ) second macroexpand   skip-eval on ; special-form: macroexpand

\ (defmacro! sym (fn* ...))
:noname ( env list -- env' form )
  2dup third eval ( env list fn-value )
  dup macro! >R   ( env list    R: fn-value )
  \ Actually def! into the repl-env, not the current one.
  \ TODO: Is that really the right thing to do? What should (let [x 1] (def! y x)) do?
  second R@ repl-env @ env-set drop ( env   R: fn-value )
  R> ;                                              special-form: defmacro!
