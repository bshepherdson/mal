\ Special forms are checked in EVAL, they're not regular symbols.

\ Each special form has a symbol it matches against; they can go in a map or
\ environment.
VARIABLE special-forms
nil new-env special-forms !

\ Repeatedly matches special forms until none matches.
\ Returns the original env and list if no special form matches.
: ?special-form ( env list -- env' list' )
  BEGIN
    dup list? 0= IF EXIT THEN
    dup emptyl?  IF EXIT THEN
    dup head special-forms @ env-find  ( env list value )
    dup some? IF execute ELSE drop EXIT THEN
  AGAIN ;

: special-form: ( xt "name" -- )
  parse-name >symbol swap   special-forms @ env-set   special-forms ! ;

\ NOTE: Special forms take the entire list, not just the arguments.

\ TODO: I'm not certain what def! is supposed to return. I settled on the value.
\ (def! sym value) ===========================================================
:noname ( env list -- env' nil )
  2dup third eval ( env list value )
  swap second     ( env value key )
  swap dup >R     ( env key value    R: value )
  \ We actually want to def into the REPL env, not the current one.
  repl-env @ env-set ( dyn-env repl-env'   R: value )
  drop R> ; special-form: def!

\ (let* (binding value ...) body) ============================================
:noname ( env list -- env' body-result )
  \ Create a new environment for the let bindings, descending from the input.
  swap new-env       ( list let-env )
  over second        ( list let-env binding-list )
  env-binding        ( list bound-env )
  swap third ;       ( bound-env body )             special-form: let*

\ (do body...) ===============================================================
:noname ( env list -- env' last-result )
  \ This loop ends one early to enable TCO.
  tail seq BEGIN dup rest some? WHILE ( env seq )
    2dup first EVAL drop  ( env seq )
    rest
  REPEAT first ( env final-ast ) ;                  special-form: do

\ (if cond true false)
:noname ( env list -- env' result )
  \ ." start of if: " dup pr-str type 4 spaces hex.s cr
  tail   dup tail >R    ( env l-cond   R: l-true )
  2dup head EVAL nip    ( env result   R: l-true )
  \ hex.s cr
  R> swap               ( env l-true result )
  dup nil? swap   mal-false = or IF tail THEN \ Falsy case ( env list )
  dup emptyl? IF drop nil ELSE head THEN
  \ ." end of if: " dup pr-str type 4 spaces hex.s cr
  ( env ast ) ; special-form: if

\ (fn* (params)|[params] body)
:noname ( env list -- env' fn )
  over swap    ( env env list )
  dup second   ( env env list params )
  swap third   ( env env params body )
  function     ( env fn ) ;                         special-form: fn*
